Download Link: https://assignmentchef.com/product/solved-solvedmutable-string-class
<br>
Consider the following Java definition of a mutable string class. class MutableString { private char[] chars = new char[200]; private int size = 0; public boolean set(char aChar, int index) { if (index &lt; 0 || index = chars.length) return false; chars[index] = aChar; return true; } public String toString() { String result = “”; for (int i = 0; i &lt; size; i++) result += chars[i]; return result; } } Suppose this class was rewritten in C++ in two ways, the first with the array that represents the list as a stack-dynamic variable, and then with the list as a heap dynamic variable. Explain when constructors and destructors would be needed. Explain why no constructors or destructors are needed in the Java implementation. Consider the following C++ template class. template class Vector { public: Vector(T values[length]) { for (int i = 0; i &lt; length; i++) list[i] = values[i]; } friend bool operator&lt;(const Vector&amp; left, const Vector&amp; right) { bool result = true; for (int i = 0; i &lt; length; i++) result &amp;= left.list[i] &lt; right.list[i]; return result; } private: T list[length]; }; int main() { int first[] = {1, 2}, second[] = {2, 3}; Vector vector1(first), vector2(second); cout &lt;&lt; (vector1 &lt; vector2) &lt;&lt; endl; return 0; } The class Vector cannot be instantiated for any arbitrary type. For example, consider the following instantiation for a wrapper integer class. class Int { public: Int(int i = 0) {this-i = i;} private: int i; }; int main() { Int first[] = {Int(1), Int(2)}, second[] = {Int(2), Int(3)}; Vector vector1(first), vector2(second); cout &lt;&lt; (vector1 &lt; vector2) &lt;&lt; endl; return 0; } Explain why the second implementation fails. What must be added to that class so this program will compile? Suppose this program were written in Java. Explain how Java allows the constraints on a generic type parameter to be specified and how they would be specified in this case Java does have one limitation, however. Although wrapper classes can be used to instantiate generic type parameters, primitive types cannot. Explain why.. template class Vector { public: Vector(T values[length]) { for (int i = 0; i &lt; length; i++) list[i] = values[i]; } friend bool operator&lt;(const Vector&amp; left, const Vector&amp; right) { bool result = true; for (int i = 0; i &lt; length; i++) result &amp;= left.list[i] &lt; right.list[i]; return result; } private: T list[length]; }; int main() { int first[] = {1, 2}, second[] = {2, 3}; Vector vector1(first), vector2(second); cout &lt;&lt; (vector1 &lt; vector2) &lt;&lt; endl; return 0; } The class Vector cannot be instantiated for any arbitrary type. For example, consider the following instantiation for a wrapper integer class. class Int { public: Int(int i = 0) {this-i = i;} private: int i; }; int main() { Int first[] = {Int(1), Int(2)}, second[] = {Int(2), Int(3)}; Vector vector1(first), vector2(second); cout &lt;&lt; (vector1 &lt; vector2) &lt;&lt; endl; return 0; } Explain why the second implementation fails. What must be added to that class so this program will compile? Suppose this program were written in Java. Explain how Java allows the constraints on a generic type parameter to be specified and how they would be specified in this case Java does have one limitation, however. Although wrapper classes can be used to instantiate generic type parameters, primitive types cannot. Explain why.